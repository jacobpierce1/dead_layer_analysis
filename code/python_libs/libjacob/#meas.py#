# this is a class for doing all common error analysis operations. the class meas
# is constructed from a numpy ndarray x and ndarray dx, or an ndarray x and a scalar x
# in which case dx is set to an array with all values dx of same shape as x.


import numpy as np



class InputError( Exception ):
    pass


class meas( object ):

    # CONSTRUCTOR
    # https://stackoverflow.com/questions/29318459/python-function-that-handles-scalar-or-arrays
    def __init__( self, x, dx, checksize=1, checktype=1 ):

        x = np.asarray( x )
        dx = np.asarray( dx )

        # type check on input
        if checktype:

            if not np.issubdtype( x.dtype, np.number ):
                raise InputError( 'x must have numeric dtype.' )

            if not np.issubdtype( dx.dtype, np.number ):
                raise InputError( 'dxx must have numeric dtype.' )

                
        # if dx.ndims is 0 then dx was input as scalar. in this case, no matter
        # what we assign dx to have same shape as x, even if x is also scalar.
        if dx.ndim == 0:

            # if both x and dx are scalars then suppress a dimension and use them.
            if x.ndim == 0:
                x = np.squeeze( x )
                dx = np.squeeze( dx )

            # if not set dx to have same shape as x
            else: 
                dx = dx * np.ones( x.shape )

                
        # by default do a check on the size of x and dx. i only
        # recommend skipping the checksize in the arithmetic functions
        # where efficiency matters. note that it only has to be called if
        # dx is not a scalar.
        else:
            if checksize:
                if x.shape != dx.shape:
                    raise InputError( 'x and dx supplied have different shape.' )

        # set instance vars and return
        self.x = x
        self.dx = dx
        return None                    

    
    
    # OVERLOAD ALL ARITHMETIC OPERATIONS.
    # x and y must be uncorrelated for any of these to make sense.
    def __add__( self, y ):

        if np.isscalar( y ):
            return meas( self.x + y,
                         self.dx,
                         checksize = 0 )

        else:
            return meas( self.x + y.x,
                         np.sqrt( self.dx **2 + y.dx **2 ),
                         checksize=0 )
    

    def __sub__( self, y ):

        if np.isscalar( y ):
            return meas( self.x - y,
                         self.dx,
                         checksize = 0 )

        else:
            return meas( self.x - y.x,
                         np.sqrt( self.dx ** 2 + y.dx ** 2 ),
                         checksize=0 )


    def __mul__( self, y ):

        if np.isscalar( y ):
            return meas( self.x * y,
                         self.dx * y,
                         checksize = 0 )
        
        else:
            return meas( self.x * y.x,
                     np.sqrt( ( self.x * y.dx ) ** 2 +
                              ( y.x * self.dx ) ** 2 ),
                     checksize=0 )


    def __div__( self, y ):

        if np.isscalar(y):
            return meas( self.x / y,
                         self.dx / y,
                         checksize = 0 )

        else:
            val = self.x / y.x
            return meas( val,
                         np.abs( val ) * np.sqrt( ( self.dx / self.x ) ** 2 +
                                                  ( y.dx / y.x ) ** 2 ),
                         checksize=0 )
        

    # only arithmetic operation that needs to be defined differently if
    # the measurement is on the right side.
    def __rdiv__( self, y ):

        if np.isscalar( y ):
            return y * ( self ** -1 )

        else:
            return __div__( y, self )
        
    # other right-hand operations: commutative. 
    __radd__ = __add__
    __rsub__ = __sub__
    __rmul__ = __mul__
    
    
    # other common operations 
    def __abs__( self ):
        return meas( np.abs( self.x ),
                     self.dx,
                     checksize=0 )

    def __neg__( self ):
        return meas( 0-self.x, self.dx, checksize=0 )

    def __str__( self ):
        return 'x: %s\ndx: %s' % ( str( self.x ), str( self.dx ) )

    def __eq__( self, y ):
        return ( self.x == y.x ) & ( self.dx == y.dx )

    def __ne__( self, y ):
        return not self.__eq__( y )

    def __repr__( self ):
        return 'Measurement:\n' + str( self )

    # use the power law of calculus
    def __pow__( self, n ):
        return meas( self.x ** n,
                     np.abs( n * self.x ** (n-1) ) * self.dx,
                     checksize=0 ) 

        
    
    # EXTENSIONS OF NUMPY / ARRAY OPERATIONS 

    # use chain rule of calculus. f and fprime must be callable.
    def apply( self, f, fprime ):
        return meas( f( self.x ),
                     np.abs( fprime( self.x ) ) * self.dx,
                     checksize=0 )


        
    # todo: methods for summing an input list or summing an 
    
    # 2: a pd.Series of value and delta arrays.
    @staticmethod
    def sum( measurements, axis=None ):
        #x, dx = measvec_to_arrays( measurements )
        return meas( np.sum( x.x, axis=axis ),
                     np.sqrt( np.sum( x.dx **2, axis=axis ) ),
                     checksize=0 ) 
    
    
    
    # input: xlist, a list or numpy array of measurements.
    # entries of xlist must be uncorrelated for error to make sense.
    def mean( xlist, axis=None ):
        return meas( np.mean( x.x, axis=axis ),
                     np.sqrt( np.sum( x.dx ** 2, axis=axis ) / x.x.size ),
                     checksize=0 )
            
            
    


############################################
# NON CLASS METHODS

# common functions
def cos( _meas ):
    return _meas.apply( np.cos, np.sin )

def sin( _meas ):
    return _meas.apply( np.sin, np.cos )

def tan( _meas ):
    return _meas.apply( np.tan, lambda x: 1 / ( np.cos(x) ** 2 ) )

def arccos( _meas ):
    return _meas.apply( np.arccos,
                        lambda x: 1 / np.sqrt( 1 - x ** 2 ) )

def arcsin( _meas ):
    return _meas.apply( np.arcsin,
                        lambda x: 1 / np.sqrt( 1 - x ** 2 ) )

def arctan( _meas ):
    return _meas.apply( np.arctan,
                        lambda x: 1 / ( 1 + x ** 2 ) )

def log( _meas ):
    return _meas.apply( np.log,
                        lambda x: 1 / x )

# sum and mean are overloaded with the class instance methods. the difference
# is those methods act on the entries of a single measurement object, whereas these
# act on an input list along the specified axis. both of these return a single
# measurement with the same dimensions as the measurements in the input list.
# note that the 
def sum(                 
    
    # # convert either list of measurements or measurement of lists into two tuples.
    # def measvec_to_arrays( measurements ):
        
        
    #     if isinstance( measurements, pd.Series ):
    #         x = measurements['value']
    #         dx = measurements['delta']
    #     else:
    #         x = np.array( [ measurements[i]['value'] for i in range(len(measurements)) ] )
    #         dx = np.array( [ measurements[i]['delta'] for i in range(len(measurements)) ] )
            
    #         return ( x, dx )
                
                

# # deprecated
# # "constructor" offers several different modes.
# def measurement( x, dx ):

#     # if not scalar, attempt to convert to np.array.
#     if not np.isscalar(x):
#         x = np.asarray(x)

#     if not np.isscalar(dx):
#         dx = np.asarray(dx)
        
#     if type(x) is np.ndarray and np.isscalar(x):
#         dx = dx * np.ones_like( x )

#     return pd.Series( [x,dx], values_index )





# def ndarray_or_scalar( x ):
#     return np.isscalar(x) or ( type(x) is np.ndarray )
