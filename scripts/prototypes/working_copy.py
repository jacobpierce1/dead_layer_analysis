# -*- coding: utf-8 -*-

# this script parses binary data generated by ttree_to_bin.cpp. there should be a test function
# to verify that it is working properly. script based on typical phys 211 scripts, specifically
# experiment 7: tac_spectrum copy.py

# date: 8.30.17
# author: jacob pierce



# my files 
from jacob_math import *
from jacob_pyplot import *
from jacob_utils import *

# reload(jacob_math)



## includes 
import array
import numpy as np
from scipy import optimize, special
import matplotlib.pyplot as plt
from math import log10, floor

import sys
import warnings
from scipy.optimize import OptimizeWarning
warnings.simplefilter("error", OptimizeWarning)



# fit n alpha peaks given vector p and array x 
# p format: sigma, eta, tau1, tau2, A1, mu1, ..., A_n, mu_n
def fitfunc_n_alpha_peaks( n, p, x ):
    return np.sum( [ map( lambda y: alpha_fit(p[4+2*i],p[4+2*i+1],p[0],p[1],p[2],p[3], y), x )  for i in range(n) ], axis=0 )  
    
    
# reference: equation 10 in Bortels 1987  
# this function is meant to be applied to scalar x, not list
def alpha_fit( A, mu, sigma, eta, tau1, tau2, x ):        
    # if eta < -0.01 or eta > 1.01:
    #     return -999
        
    # prevent overflow by computing logs and then exponentiating, at the expense of some
    # floating pt error. logtmpz is the log of the 2 analagous terms in the integrand.
    tauz = [tau1, tau2]
    logtmpz = [ (x-mu)/tau + sigma**2.0/(2*tau**2.0) + np.log( special.erfc( (x-mu)/sigma + sigma/tau) / np.sqrt(2) ) for tau in tauz ]
    return ( A/2.0 )  * ( (1-eta)/tau1 * np.exp(logtmpz[0])
                            + (eta/tau2) * np.exp(logtmpz[1])   ) 



# evaluate the fwhm on the set of points provided. up to used to specify an appropriate
# number of entries to balance speed and precision. function must be scalar outupt for 
# scalar input. assumes that x is a sorted array, otherwise this function would take forever.
def fwhm_from_func( function, x, dx=[] ):
    x = np.array(x)
    y = function( x )
    return fwhm_from_data( x, y, dx )
    


def fwhm_from_data( x, y, dx=[] ):
    x = np.array(x) 
    y = np.array(y) 
    
    if( x.size != y.size ):
        print "ERROR: x and y have different size."
        print "x size = " + str(x.size)
        print "y size = " + str(y.size)
        sys.exit(0)
        
    # find positions of x 
    ymax = np.amax(y)
    xmax_arr = x[ np.argwhere( y == ymax ).flatten() ]
        
    # find rightmost and leftmost / top and bottom half max positions
    halfmax = ymax / 2.0
    halfmax_positions = np.array( [[0.0,0.0]]*2 )
    lefty = xcut( x, y, [x[0], xmax_arr[0] ] )
    righty = xcut( x, y, [xmax_arr[-1], x[-1] ] )
    
    halfmax_positions[0][0] = x[ np.argwhere( lefty >= halfmax )[0] ]
    halfmax_positions[0][1] = x[ np.argwhere( lefty <= halfmax )[-1] ]
    halfmax_positions[1][0] = x[ np.argwhere( righty >= halfmax )[-1] ]
    halfmax_positions[1][1] = x [np.argwhere( righty <= halfmax )[0] ]

    average_halfmax_positions = [ np.average(halfmax_positions[i]) for i in range(2) ]
    average_halfmax_uncertainties = [ np.ediff1d( halfmax_positions[i] )[0] / 2.0 for i in range(2) ]
    fwhm = 0-np.ediff1d( average_halfmax_positions )[0]
    
    return ( fwhm, average_halfmax_positions, average_halfmax_uncertainties )
    
    




## constants
test_dir = '../extracted_ttree_data/'
test_file = "deadlayerdet3rt/deadlayerdet3rt_16_16.bin"
test_file = test_dir + test_file
# test_file = "output/deadlayerdet3cent/deadlayerdet3cent_1_1.txt"
# test_file = "output/test/test_29_25.bin"




# extract next row from the file. file assumed to already be opened.
def read_doubles_from_bin( f, buf ):
    bytes = f.read(8*2 )  # since we write 2 doubles for each event: efront and eback.
    if( not bytes ): return 0;
    buf[:] = array.array('d', bytes) 
    return 1

    

# construct histogram count arrays from the file
def construct_histo_arrays( f, efront_histo, eback_histo ):

    buf = array.array( 'd', [0.0, 0.0] )  # data gets read into here.

    while( read_doubles_from_bin( f, buf ) ):
        efront = buf[0]
        eback = buf[1]
        
        # used this to verify that read was successful.
        # print efront
        # print eback
        # print int(efront)
        # print int(eback)
    
        efront_histo[ int( efront ) ] += 1
        eback_histo[ int( eback ) ]  += 1





###############################################################
## SCRIPTNG ###################################################
###############################################################

# x axis
x = np.array( range(4096) )

filename = test_file

try:
    f = open( filename, "rb" )
except IOError:
    print "ERROR: unable to open file: " + filename
    sys.exit(0)

# these are passed as reference to avoid unnecessary copying
efront_histo = [0] * 4096
eback_histo  = [0] * 4096

construct_histo_arrays( f, efront_histo, eback_histo )

f.close()


# plot the histogram without fit yet 
plt.clf()
ax = plt.axes()
plot_bounds = [2630, 3300 ]
plot_histo( ax, x, efront_histo, plot_bounds=plot_bounds, 
                title = "Rotated Alpha Source, Middle Pixel",
                xlabel = "Energy (keV)",
                ylabel = "Counts", logscale=1       )


# params: sigma, eta, tau1, tau2, A1, u1, ..., An, un )    
# p0 = np.array( [ 100., 10., 100., 10., 10., 10., 10., 10. ])
# p0 = np.array( [2.0]*8 )
# p0 = np.array( [10.0]*8 )
# p0 = np.array( [ 200.0, 2829.0, 200.0, 2853.0, 10.0, 0.5, 1.0, 1.0 ])
# p0 = [10.0, 0.5, 1.0, 1.0, 100.0, 2655.0, 100.0, 2678.0, 200.0, 2831.0, 200.0, 2853.0 ]
# p0 = [100.0, 0.5, 200.0, 200.0, 2000.0, 2829.0, 2000.0, 2853.0 ]
# p0 = [100.0, 0.7, 200.0, 200.0, 2000.0, 2853.0 ]


## parameterts for a fitfunc with n_alpha_peaks_eta1
## fit_bounds = [2710, 2758]
## fit_bounds = [ 2883, 2935 ]
#fit_bounds = [ 2819, 2935 ]
#
#p0 = [6.0, 5.5]
## p0 += [ 1000.0, 2719.0]
## p0 += [ 2000.0, 2744.0]
#p0 += [5000.0, 2896.0 ]
#p0 += [2000.0, 2919.0 ]
#p0 = np.array(p0)
#
## fitfunc = fitfunc_2_alpha_peaks
## fitfunc = fitfunc_n_alpha_peaks_abstract(1)  
## fitfunc = fitfunc_n_alpha_peaks_abstract(4)  
#fitfunc = n_fitfuncs_abstract( fitfunc_n_alpha_peaks_eta1, 2 )




# parameters for fitfunc with a free eta.

##winner 
#fit_bounds = [ 2819, 2935 ]
#p0 = [ 4.0, 0.9, 5.2, 5.0 ]
#p0 += [ 2000.0, 2895.0 ]
#p0 += [ 3000.0, 2919.0 ]
#fitfunc = n_fitfuncs_abstract( fitfunc_n_alpha_peaks, 2 )



fit_bounds = [ 2810, 2935 ]
p0 = [ 6.0, 0.99, 42.0, 1.6 ]
p0 += [ 2000.0, 2895.0 ]
p0 += [ 4000.0, 2919.0 ]
fitfunc = n_fitfuncs_abstract( fitfunc_n_alpha_peaks, 2 )






reduc_chisq, dof, pf, pferr = jacob_least_squares( x, efront_histo, np.sqrt(efront_histo), fit_bounds, p0, fitfunc )
mu = pf[3]

print "reduced chisq: " + str(reduc_chisq)
print pf
print pferr

#
#reduced_fitfunc = lambda x: fitfunc( pf, x )
#fwhm, fwhm_x, fwhm_dx = fwhm_from_func( reduced_fitfunc, np.linspace(mu-100, mu+100, 1000) )
#print "fwhm = " + str(fwhm)
#print "fwhm coords = " + str(fwhm_x) 

# fwhm, fwhm_x, fwhm_dx = fwhm_from_func( fitfunc, linspace(mu-100, mu+100) )



add_fit_to_plot( ax, x, fit_bounds, pf, pferr, fitfunc )



# add a description of the fit to the plot
# note: \mathrm{} is replacement for \text{}
fit_str = "$ f(E) = \\sum_i \\frac{A_i}{2 \\tau}    \
                    \\cdot \\exp \\left[   \
                            \\frac{E-\\mu_i}{\\tau}   \
                            + \\frac{\\sigma^2}{2 \\tau^2 }  \
                    \\right] \
                    \\cdot \\mathrm{erfc} \\left[   \
                            \\frac{1}{\\sqrt{2}} \\left(  \
                                    \\frac{x-\\mu}{\\sigma}    \
                                    + \\frac{\\sigma}{\\tau_1}   \
                            \\right)   \
                    \\right] $"


### FORMATTING FOR THE CASE OF AN ETA=1 fit .
#A_measurements = format_measurement_vector( "A", pf[range(2,pf.size,2)].tolist(), pferr[range(2,pf.size,2)].tolist() )
#
#mu_measurements = format_measurement_vector( "\\mu", pf[range(3,pf.size,2)].tolist(), pferr[range(3,pf.size,2)].tolist() )
#
#tau_str = " $ \\tau = %s \\pm %s $" % tuple( sigfig( pf[0], pferr[0] ) )
#
#sigma_str = "$ \\sigma = %s \\pm %s $" % tuple( sigfig( pf[1], pferr[1] ) )
#
#chisq_str = "$ \\tilde{\\chi}^2 = %s \; (\mathrm{dof} = %d ) $" % ( sigfig(reduc_chisq, 0.01)[0], dof )
#
#fit_str += '\n' + '\n'.join( [ A_measurements, mu_measurements, tau_str, sigma_str, chisq_str ] )


## FORMATTING FOR A FREE ETA FIT
# p format: sigma, eta, tau1, tau2, A1, mu1, ..., A_n, mu_n
A_measurements = format_measurement_vector( "A", pf[range(4,pf.size,2)].tolist(), pferr[range(4,pf.size,2)].tolist() )

mu_measurements = format_measurement_vector( "\\mu", pf[range(5,pf.size,2)].tolist(), pferr[range(5,pf.size,2)].tolist() )


sigma_str = "$ \\sigma = %s \\pm %s $" % tuple( sigfig( pf[0], pferr[0] ) )

eta_str = "$ \\eta = %s \\pm %s $" % tuple( sigfig( pf[1], pferr[1] ) )

tau1_str = " $ \\tau_1 = %s \\pm %s $" % tuple( sigfig( pf[2], pferr[2] ) )
tau2_str = " $ \\tau_2 = %s \\pm %s $" % tuple( sigfig( pf[3], pferr[3] ) )

chisq_str = "$ \\tilde{\\chi}^2 = %s \; (\mathrm{dof} = %d ) $" % ( sigfig(reduc_chisq, 0.01)[0], dof )

fit_str += '\n' + '\n'.join( [ A_measurements, mu_measurements, sigma_str, eta_str, tau1_str, tau2_str, chisq_str ] )








ax.text(0.70, .95, fit_str, transform=ax.transAxes, fontsize=15,
    verticalalignment='top')
    



# generate the ax and return so that we can keep modifying.
# ax = plot_histo_and_fit( x, efront_histo )



# pf = np.array([round_to_1 (x) for x in pf])
# pferr = np.array([round_to_1 (x) for x in pferr])




# textfit  = "$ f(E) = \\frac{1-\\eta}{\\tau_1} \\cdot \\exp \\left( \\frac{E-\\mu}{\\tau_1} + \\frac{\\sigma^2}{2 \\tau_1^2 }  \\right)    \
#                    \\cdot \\text{erf} \\left(  $" # \\frac{1}{\\sqrt{2}} \\left(  \\frac{x-\\mu}{\\sigma} + \\frac{\\sigma}{\\tau_1} \\right) \\right)  $"
                    #+ (eta/tau2) * np.exp( (x-mu)/tau2 + sigma**2.0/(2*tau2**2.0)) \
                    #* erf( ( (x-mu)/sigma + sigma/tau2) / np.sqrt(2) )  \
                    #  $"
#textfit = ""
#textfit = '$ N(t) = N_0 e^{ -x/x_0} + B $ \n' \
#           '$N_0 = %.0f \pm %.0f$ counts \n' \
#           '$x_0 = %.1f \pm %.1f$ channels \n' \
#           '$B = %.1f\pm %.1f$ counts \n' \
#           '$\\tilde{\chi}^2 = %.2f$ \n' \
#           % (pf[0], pferr[0], pf[1], pferr[1], pf[2], pferr[2], reduc_chisq )
#
# ax.text(0.7, .87, textfit, transform=ax.transAxes, fontsize=18,
#        verticalalignment='top')





